//
//  BLEController for BackgroundBLE project
//
//  Owns and handles BLE communications and events.
//
//  Created by D S on 8/16/20.
//

import Foundation
import CoreBluetooth
import UIKit
// structure to pas additional information about Peripheral into View
struct PeripheralDescr: Hashable {
    // using identifier as it should be unique
    static func == (lhs: PeripheralDescr, rhs: PeripheralDescr) -> Bool {
        return lhs.peripheral == rhs.peripheral
    }
    
    var name : String
    let services : [CBUUID]
    let identifier : UUID
    var peripheral : CBPeripheral
}

class BLEModel : NSObject, CBCentralManagerDelegate, CBPeripheralManagerDelegate, ObservableObject {
    var backgroundTaskId: UIBackgroundTaskIdentifier = .invalid
    let reconnectInterval = 15 // seconds
    
    var centralManager: CBCentralManager! = nil
    var peripheralManager: CBPeripheralManager! = nil
    @Published var connPeripheralDelegate : ConnectionToPeripheral
    // array of peripheral scanned in central mode
    @Published var peripherals : [PeripheralDescr] = []
    @Published var connectedPeripheralID = [UUID]()
    var timer = RepeatingTimer(timeInterval: 5)
    var timerToReconnect : Timer?
    // UUIDs of service and characteristic -- hardcoded
    // Can be generated by running `uuidgen` in the Mac's terminal
    // source: https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/PerformingCommonPeripheralRoleTasks/PerformingCommonPeripheralRoleTasks.html#//apple_ref/doc/uid/TP40013257-CH4-SW1
    
    var myServiceUUID: CBUUID
    var myCharacteristicUUID: CBUUID
    
    var myService: CBMutableService
    var myCharacteristic: CBMutableCharacteristic
    var centralManagerIsOn: Bool {
        get {
            if self.centralManager != nil {
                return true
            } else {
                return false
            }
        }
        set (toggleCentral){
            if toggleCentral == true {
                self.centralManager = CBCentralManager(delegate: self, queue: nil)
            } else {
                //
                if self.centralManager.isScanning == true { self.cancelScan() }
                self.centralManager = nil
            }
        }
    }
    var peripheralManagerIsOn: Bool {
        get {
            if self.peripheralManager != nil {
                return true
            } else {
                return false
            }
        }
        set (togglePress){
            if togglePress == true {
                self.peripheralManager = CBPeripheralManager(delegate: self, queue: nil)
                //self.startAdvertising()
            } else {
                if self.peripheralManager.isAdvertising == true { self.stopAdvertising() }
                // destroys peripheral object
                // will implicitly call Cancel connection on Central
                self.peripheralManager = nil
            }
        }
    }
    
    override init() {
        
        self.myServiceUUID = CBUUID(string: "71DA3FD1-7E10-41C1-B16F-4430B506CDE7")
        self.myCharacteristicUUID = CBUUID(string: "523D0E52-01CE-4AA7-A525-E99AC9FE2AC6")
        
        self.myCharacteristic = CBMutableCharacteristic(type: self.myCharacteristicUUID, properties: [.notify, .read, .write], value: nil, permissions: [.readable, .writeable])
        
        self.myService = CBMutableService(type: self.myServiceUUID, primary: true)
        self.myService.characteristics = [self.myCharacteristic]
        self.connPeripheralDelegate = ConnectionToPeripheral(service: myServiceUUID, characteristic: myCharacteristicUUID)
        super.init()

    }
    
    func startScan() {
        peripherals = []
        // start scanning for all devices
        // to scan in the background, need to specify serviceUUID
        centralManager?.scanForPeripherals(withServices: [self.myServiceUUID], options: [CBCentralManagerScanOptionAllowDuplicatesKey:false])
        print("started the scan")
    }
    
    func cancelScan() {
        self.centralManager?.stopScan()
        print("Scan Stopped")
        print("Number of Peripherals Found: \(peripherals.count)")
    }
 // MARK: -- Handlers for Central BLE Events
    
    func centralManagerDidUpdateState(_ central: CBCentralManager) {
        switch central.state {
            case CBManagerState.poweredOn:
                self.startScan()
                print("central is powered on")
            case CBManagerState.unauthorized:
                print("Unauthorized for BLE")
            case CBManagerState.poweredOff:
                timer.suspend()
                print("Powered Off from central manager")
            default:
                print("other error encountered")
        }
    }
    func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral,advertisementData: [String : Any], rssi RSSI: NSNumber) {
        print ("Detected")
        // get either the peripheral name or the name it is advertising
        let name : String = utilGetName(peripheral, advertisementData)
        let uuids : [CBUUID] = utilUUIDsOrDefault(advertisementData)
        peripherals.append(PeripheralDescr(name: name, services: uuids, identifier: peripheral.identifier, peripheral: peripheral ))
        
        print("Found new pheripheral devices with services")
        print("Peripheral name: \(String(describing: peripheral.identifier))")
        print("RSSI   : \(RSSI)")
        print("**********************************")
        print ("Advertisement Data : \(advertisementData)")
    }
    
    // Called from UI on tap
    func connect(_ peripheral: PeripheralDescr) {
        self.centralManager?.connect(peripheral.peripheral, options: nil)
        self.connectedPeripheralID.append(peripheral.identifier)
    }
    
    // Called when connection was successfull
    func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
        print("*****************************")
        print("Connection complete")
        print("Peripheral info: \(String(describing: peripheral))")
        
        //Stop Scan- We don't need to scan once we've connected to a peripheral.
        centralManager?.stopScan()
        print("Scan Stopped")
        
        //Discovery callback
        peripheral.delegate = connPeripheralDelegate
        //Only look for services that matches transmit uuid
        peripheral.discoverServices([self.myServiceUUID])
        
    }
    // MARK: -- Handlers for Peripheral Events
    func startAdvertising() {

        if self.peripheralManager?.isAdvertising == true {
            return;
        } else {
            self.peripheralManager?.startAdvertising([CBAdvertisementDataLocalNameKey: "BLEFromIOS",
                                                      CBAdvertisementDataServiceUUIDsKey: [self.myServiceUUID]])
        }
    }
    
    func stopAdvertising() {
        self.peripheralManager?.stopAdvertising()
        print("peripheral stopped advertising")
    }
    
    func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?) {
        if error != nil {
            print(error as Any)
        } else {
            print ("started advertising")
        }
    }
    func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager) {
        switch peripheral.state {
        case .poweredOn:
            print("Peripheral on")
            // in case the service has already been added
            self.peripheralManager?.removeAllServices()
            self.peripheralManager?.add(self.myService)
            self.startAdvertising()
        case .poweredOff:
            print("Peripheral off")
            timer.suspend()
        case .unauthorized:
            print("Bluetooth permissions missing")
        default:
            print("Peripheral in unsupported mode")
        }
    }
    
    func peripheralManager(_ peripheral: CBPeripheralManager, central : CBCentral, didSubscribeTo characteristic : CBCharacteristic) {
        print("Central substcribed to characteristic \(characteristic)")
    
        
    }
    func peripheralManager(_ peripheral: CBPeripheralManager,
                          didReceiveWrite requests: [CBATTRequest]) {
      guard let request = requests.first, let data = request.value else { return }
      let message = String(decoding: data, as: UTF8.self)
    }

    private func tryReconnect(_ central: CBCentralManager, to peripheral: CBPeripheral) {
        DispatchQueue.main.async { // while in background mode Timer would work only being in main queue
            self.backgroundTaskId = UIApplication.shared.beginBackgroundTask (withName: "reconnectAgain") {
                UIApplication.shared.endBackgroundTask(self.backgroundTaskId)
                self.backgroundTaskId = .invalid
            }
            
        }
    }
    func centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {
        self.tryReconnect(central, to: peripheral)
    }

    func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {
        self.tryReconnect(central, to: peripheral)
    }
}
